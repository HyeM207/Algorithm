# 정렬 

<p> 종류 6가지 </p>
1. 버블
2. 선택
3. 삽입 
4. 퀵 
5. 병합 
6. 기수 

<br>

## 1. 버블 정렬 
> 데이터 인접 요소끼리 비교해서 swap 연산 진행 

<b>특징 </b>
1. 구현은 간단하지만 시간 복잡도는 o(n^2)로 다른 알고리즘보다 느리다

<b> 정렬 과정 </b>
1. 비교 연산이 필요한 루프 범위 설정 
2. 인접한 데이터 값을 비교
3. swap 조건(크다/작다)에 부합하면 swap 연산 수행 
4. 루프 범위 끝날 때 까지 (2)~(3) 반복
5. 정렬 영역 선택하고, 다음 루프 실행 시 해당 영역 제외함
6. 비교 대상이 없을 때까지 (1)~(5) 반복함 

<b>코드</b>
<pre>
<code>
n = int(input())
a = []

for i in range(n) : 
    a.append(int(input()))

for i in range(0, n-1):
    for j in range(0, n-1-i):
        if a[j] > a[j+1] : 
            a[j+1], a[j] = a[j], a[j+1]


for e in a:
    print(e)

# 문제: [BOJ] 2750. 수 정렬하기
</pre>
</code>

<br><br>
<hr>


## 2. 선택 정렬 
> 최대/최소 값을 데이터가 나열된 순으로 찾아가며 선택하는 기법

<b>특징 </b>
1. 구현은 간단하지만 시간 복잡도는 o(n^2)로 다른 알고리즘보다 느리다 (코테에서 사용 X)

<b> 정렬 과정 </b>
1. 남은 정렬 부분에서 최소/최대값을 찾는다.
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 (1)값과 swap
3. 가장 앞에 있는 데이터 위치를 변경해 남은 정렬 부분의 범위 축소함
4. 전체 데이터 크기만큼 index가 커질 때까지(남은 정렬 부분이 없을 때까지) 반복


<b>코드</b>
<pre>
<code>
a = list(input())

for i in range(len(a)):
    # 최댓값의 인덱스 구하기
    maxIdx = i 
    for j in range(i+1, len(a)):
        if int(a[maxIdx]) < int(a[j]) :
            maxIdx = j

    # 최댓값 swap
    if maxIdx != i : 
        a[i], a[maxIdx] = a[maxIdx], a[i]

print(''.join(a)) 

# 문제: [BOJ] 1427. 소트인사이드
</pre>
</code>